// app/build.gradle 文件
apply plugin: 'com.android.application'

def appDir = "$rootProject.ext.appDir"

ext.plugin = [
    id: "LspModule",
    version: 1,
    targetPattern: 'com.finalwire.aida64|com.godevelopers.XposedChecker',
    description: "测试LSP",
    proguard: false
]

def getExtVar(name, val) {
    try {
        if (project.ext.plugin.containsKey(name)) {
            return project.ext.plugin[name]
        }
    } catch (ex) {
        throw ex
    }
    return val
}

def getPluginExtraInfo = { ->
    try {
        def patchConfig = [
                id           : getExtVar("id", ""),
                version      : android.defaultConfig.versionCode,
                versionName  : "${android.defaultConfig.versionName}",
                description  : getExtVar("description", ""),
                targetPattern: getExtVar("targetPattern", "")
        ];

        return patchConfig
    } catch (Throwable t) {
        t.printStackTrace();
        println "error generate plugin meta config!"
    }
}

android {
    compileSdkVersion 33 // 使用的 SDK 版本

    defaultConfig {
        applicationId "com.example.myapp"  // 设置包名
        minSdkVersion 21  // 最低 SDK 版本
        targetSdkVersion 33// 目标 SDK 版本
        versionCode 1  // 版本号
        versionName "1.0"  // 版本名称
        ndkVersion "26.1.10909125"
    }

    packagingOptions {
        jniLibs {
            // 将此项设置为 false，相当于通知系统不要压缩 so 文件
            useLegacyPackaging = false
        }
    }

    signingConfigs {
        release {
            storeFile file("${appDir}/tsh.jks")
            storePassword "12345678"
            keyAlias "test"
            keyPassword "12345678"
        }
    }


    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release

            externalNativeBuild {
                cmake {
                    abiFilters 'arm64-v8a', 'armeabi-v7a'
                    cppFlags "-fvisibility=hidden -fvisibility-inlines-hidden -O2 -s -Wno-unused-value"
                    cFlags "-fvisibility=hidden -fvisibility-inlines-hidden -O2 -s -Wno-unused-value"
                    cppFlags += " -DLOG_DISABLED=1"
                }
            }
        }
    }

    applicationVariants.all { variant ->
        if ('release'.equals(variant.buildType.name) && getExtVar("proguard", true)) {
            def mergeDexTask = tasks.findByName("mergeDex${variant.name.capitalize()}")
            def assembleTask = tasks.findByName("assemble${variant.name.capitalize()}")
            if (mergeDexTask && assembleTask) {
                def processDexWithJarTask = project.tasks.create("processDexWithJarFor${variant.name.capitalize()}", JavaExec) {
                    // 配置JAR路径（指向libs目录下的你的JAR）
                    classpath = files("${appDir}/libs/app.jar")

                    // 指定JAR的主类
                    mainClass = "org.example.app.App"

                    def jar = file("${appDir}/libs/app.jar")

                    outputs.upToDateWhen { false }

                    doFirst {
                        def allOutputFiles = []
                        def outputDir = mergeDexTask.outputs.files.singleFile

                        println "[DEBUG] mergeDex输出目录：${outputDir.absolutePath}"
                        println "[DEBUG] 目录是否存在：${outputDir.exists()}"

                        if (outputDir.exists() && outputDir.isDirectory()) {
                            outputDir.eachFileRecurse { file ->
                                if (file.isFile() && file.name.endsWith(".dex")) {
                                    allOutputFiles.add(file.absolutePath)
                                    println "[DEBUG] 找到Dex文件：${file.absolutePath}"
                                }
                            }
                        } else {
                            println "[WARNING] mergeDex输出目录不存在或不是目录！"
                        }

                        args = allOutputFiles

                        println "开始执行JAR文件：${jar.absolutePath}"
                        println "传递的参数：${args}"
                    }


                    standardOutput = new ByteArrayOutputStream()
                    errorOutput = new ByteArrayOutputStream()
                    doLast {
                        println "[PROCESS] JAR输出：\n${standardOutput.toString()}"
                        println "[PROCESS] JAR错误：\n${errorOutput.toString()}"
                    }
                }

                processDexWithJarTask.dependsOn(mergeDexTask)
                packageRelease.dependsOn(processDexWithJarTask)
            }
        }


        variant.outputs.each { output ->

            //if (output.outputFile != null && output.outputFile.name.endsWith('.apk')
            //        &&'release'.equals(variant.buildType.name)) {
            //    output.outputFileName  = "${pluginName}_v${variant.versionName}_${buildTime()}.apk"
            //}

            variant.packageApplication.doLast {
                def apk = output.outputFile

                def configs = getPluginExtraInfo() as Map<String, Object>
                def index = 0
                def extraInfo = ""
                configs.entrySet().forEach {
                    extraInfo += (index++ == 0 ? "" : ",") + "${it.key}=${it.value.toString()}"
                }
                println "Info: ${extraInfo} install ${apk}"
                exec {
                    commandLine "java", "-jar", "${appDir}/libs/walle-cli-all.jar", "put", "-e", extraInfo, "${apk}", "${apk}"
                }

                def variantName = variant.name.capitalize()
                if (variantName == "Release" && getExtVar("upload", false)) {
                    logInfo("upload upload upload ${pluginName}")

                    def pluginId = getPluginhName()
                    def description = configs.get("description")
                    def md5sum = getFileMd5(apk)
                    exec {
                        commandLine "curl", "-s", "-X", "POST", "http://101.43.17.137:8001/plugin/upload",
                              "-F", "id=${pluginId}",
                              "-F", "description=${description}",
                              "-F", "md5sum=${md5sum}",
                              "-F", "file=@${apk.absolutePath}"
                    }
                }
            }
        }


    }

    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            // version "3.22.1+"
        }
    }
}

dependencies {
    compileOnly files('libs/XposedBridgeAPI-89.jar')
}
